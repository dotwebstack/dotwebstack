@prefix elmo: <http://dotwebstack.org/def/elmo#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix dc: <http://purl.org/dc/elements/1.1/>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix http: <http://www.w3.org/2011/http#>.

@prefix config: <http://dotwebstack.org/configuration/>.

#Frontend
GRAPH config:MainStage {

  # We state that any URI containg /id/ should be considered as a non-information resource. 303 redirection is required.
  # Redirect URL's that contain /id/ to URL's that have this replaced by /doc/

  # Old syntax
  # Double escaping of \\ is needed, because turtle uses a backslash as escape character as well.
  config:NonInformationResourceRedirectionOLD a elmo:Redirection;
    elmo:urlPattern "^(.+)\\/id\\/(.+)$";
    elmo:redirectTemplate "$1\\/doc\\/$2";
  .
  
  # New syntax (using JAX-RS format)
  config:NonInformationResourceRedirection a elmo:Redirection;
    elmo:urlPattern "{path}/id/{reference}";
    elmo:redirectTemplate "{path}/doc/{reference}";
  .

  # A ValueMapper maps "something" to "something"
  # A ValueMapper that maps the original URL to the config:Subject parameter
  # Source and target might also be another valuemapper, so you can chain ValueMappers
  # Pattern and Template are optional, without these, target will get the value of source
  # Default replacement processor is the JAX-RS uri templating
  config:SubjectFromUrl a elmo:ValueMapper;
    elmo:source http:requestURI;
    elmo:pattern "{path}/id/{reference}";
    elmo:template "{path}/doc/{reference}";
    elmo:target config:Subject;
  .
  
  # --- Informal from here, as examples how we could extend the ValueMapper structure ---
  # Other more specific ValueMappers might also exist
  config:SubjectFromUrl a elmo:RegexValueMapper;
    elmo:source http:requestURI;
    elmo:pattern "^(.+)\\/id\\/(.+)$";
    elmo:template "$1\\/doc\\/$2";
    elmo:target config:Subject;
  .
  # Or even something completely different
  config:AndNowForSomethingCompletelyDifferent a elmo:HashDecoderValueMapper;
    elmo:source http:body;
    elmo:algorithm "base64";
    elmo:target config:HashOfBody;
  .
  # Chaining
  config:ChainedFromUrl a elmo:ValueMapper;
    elmo:source http:requestURI;
    elmo:pattern "{path}/id/{reference}";
    elmo:template "{path}/doc/{reference}";
    elmo:target [
      a elmo:HashDecoderValueMapper;
      elmo:algorithm "base64";
      elmo:target config:HasOfBody
    ];
  .
  # --- Informal till here ---

  # A default representation to be used for any dereferenceable URI's. Two separate representations are needed
  # (A) The representation that matches a /resource path, and uses the ?subject=... query to map to the config:Subject parameter
  config:ResourceRepresentation a elmo:Representation;
    elmo:urlPattern "/resource";
    elmo:parameterMapper config:SubjectFromQuery;
    elmo:informationProduct config:ResourceInformationProduct
  .
  # (B) The representation that matches a /doc/ path, and uses the original URL to map to the config:Subject parameter
  config:ResourceRepresentation a elmo:Representation;
    elmo:urlPattern "/doc/{reference}";
    elmo:parameterMapper config:SubjectFromUrl;
    elmo:informationProduct config:ResourceInformationProduct
  .

}

#Backend

# NB: The use of ?SUBJECT (a bounded variable) is recommended above the use of <${SUBJECT}> (a generic template variable)
#     At this moment, ?SUBJECT only works for string literals, so cannot be used in this case

GRAPH config:MainStage {

  config:SubjectParameter a elmo:TermFilter;
    elmo:name "SUBJECT";
    elmo:shape [
      sh:nodeKind sh:IRI;
    ]
  .
  
  config:ResourceInformationProduct a elmo:InformationProduct;
    elmo:requiredParameter config:SubjectParameter;
    elmo:query '''
      CONSTRUCT {
        <{$SUBJECT}> ?p ?o
      }
      WHERE {
        <{$SUBJECT}> ?p ?o
      }
    ''';
  .
  
}